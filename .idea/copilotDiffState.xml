<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.google.gms.google.services)&#10;    alias(libs.plugins.devtool.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.a1.sitesync&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.a1.sitesync&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_23&#10;        targetCompatibility = JavaVersion.VERSION_23&#10;    }&#10;    kotlin {&#10;        jvmToolchain(23)&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.firebase.auth)&#10;    implementation(libs.androidx.credentials)&#10;    implementation(libs.androidx.credentials.play.services.auth)&#10;    implementation(libs.googleid)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.analytics)&#10;&#10;&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.work.runtime.ktx)&#10;    implementation(libs.androidx.adapters)&#10;&#10;    // If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)&#10;    // See Add the KSP plugin to your project&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;&#10;    // The following line is optional, as the core library is included indirectly by camera-camera2&#10;    implementation(libs.androidx.camera.core)&#10;    implementation(libs.androidx.camera.camera2)&#10;    // If you want to additionally use the CameraX Lifecycle library&#10;    implementation(libs.androidx.camera.lifecycle)&#10;    // If you want to additionally use the CameraX VideoCapture library&#10;    implementation(libs.androidx.camera.video)&#10;    // If you want to additionally use the CameraX View class&#10;    implementation(libs.androidx.camera.view)&#10;    // If you want to additionally add CameraX ML Kit Vision Integration&#10;    implementation(libs.androidx.camera.mlkit.vision)&#10;    // If you want to additionally use the CameraX Extensions library&#10;    implementation(libs.androidx.camera.extensions)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.navigation.runtime.ktx)&#10;    implementation(libs.androidx.material.navigation)&#10;&#10;    implementation(libs.koin.android)&#10;    implementation(libs.koin.androidx.compose)&#10;    implementation(libs.cloudinary.android)&#10;    implementation(libs.pdfbox.android)&#10;    implementation(&quot;io.coil-kt:coil-compose:2.3.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.google.gms.google.services)&#10;    alias(libs.plugins.devtool.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.a1.sitesync&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.a1.sitesync&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_23&#10;        targetCompatibility = JavaVersion.VERSION_23&#10;    }&#10;    kotlin {&#10;        jvmToolchain(23)&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.firebase.auth)&#10;    implementation(libs.androidx.credentials)&#10;    implementation(libs.androidx.credentials.play.services.auth)&#10;    implementation(libs.googleid)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.firebase.analytics)&#10;&#10;&#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.work.runtime.ktx)&#10;&#10;    // If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)&#10;    // See Add the KSP plugin to your project&#10;    ksp(libs.androidx.room.compiler)&#10;&#10;&#10;    // The following line is optional, as the core library is included indirectly by camera-camera2&#10;    implementation(libs.androidx.camera.core)&#10;    implementation(libs.androidx.camera.camera2)&#10;    // If you want to additionally use the CameraX Lifecycle library&#10;    implementation(libs.androidx.camera.lifecycle)&#10;    // If you want to additionally use the CameraX VideoCapture library&#10;    implementation(libs.androidx.camera.video)&#10;    // If you want to additionally use the CameraX View class&#10;    implementation(libs.androidx.camera.view)&#10;    // If you want to additionally add CameraX ML Kit Vision Integration&#10;    implementation(libs.androidx.camera.mlkit.vision)&#10;    // If you want to additionally use the CameraX Extensions library&#10;    implementation(libs.androidx.camera.extensions)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.navigation.runtime.ktx)&#10;    implementation(libs.androidx.material.navigation)&#10;&#10;    implementation(libs.koin.android)&#10;    implementation(libs.koin.androidx.compose)&#10;    implementation(libs.cloudinary.android)&#10;    implementation(libs.pdfbox.android)&#10;    implementation(&quot;io.coil-kt:coil-compose:2.3.0&quot;)&#10;    implementation(&quot;com.google.code.gson:gson:2.8.9&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/CameraScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/CameraScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;@Composable&#10;fun CameraScreen(onNext: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        Button(onClick = onNext, modifier = Modifier.padding(padding)) {&#10;            Text(&quot;Go to OverlayScreen&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/FormScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/FormScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;@Composable&#10;fun FormScreen(onNext: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        Button(onClick = onNext, modifier = Modifier.padding(padding)) {&#10;            Text(&quot;Go to CameraScreen&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/MainApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/MainApp.kt" />
              <option name="originalContent" value="package com.a1.sitesync&#10;&#10;import android.app.Application&#10;import androidx.room.Room&#10;import com.a1.sitesync.data.database.AppDatabase&#10;import com.a1.sitesync.di.koinModule&#10;import com.cloudinary.android.MediaManager&#10;import org.koin.android.ext.koin.androidContext&#10;import org.koin.android.ext.koin.androidLogger&#10;import org.koin.core.context.startKoin&#10;&#10;class MainApp : Application() {&#10;    companion object {&#10;        lateinit var instance: MainApp&#10;            private set&#10;    }&#10;&#10;    lateinit var database: AppDatabase&#10;        private set&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;        instance = this&#10;        database = Room.databaseBuilder(&#10;            this,&#10;            AppDatabase::class.java,&#10;            &quot;site_sync_db&quot;&#10;        ).build()&#10;        startKoin {&#10;            androidLogger()&#10;            androidContext(this@MainApp)&#10;            modules(koinModule)&#10;        }&#10;        val config = mapOf(&#10;            &quot;cloud_name&quot; to &quot;YOUR_CLOUD_NAME&quot;,&#10;            &quot;api_key&quot; to &quot;YOUR_API_KEY&quot;,&#10;            &quot;api_secret&quot; to &quot;YOUR_API_SECRET&quot;&#10;        )&#10;        MediaManager.init(this, config)&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import android.app.Application&#10;import androidx.room.Room&#10;import com.a1.sitesync.data.database.AppDatabase&#10;import com.a1.sitesync.di.appModule&#10;import com.cloudinary.android.MediaManager&#10;import org.koin.android.ext.koin.androidContext&#10;import org.koin.android.ext.koin.androidLogger&#10;import org.koin.core.context.startKoin&#10;&#10;class MainApp : Application() {&#10;    companion object {&#10;        lateinit var instance: MainApp&#10;            private set&#10;    }&#10;&#10;    lateinit var database: AppDatabase&#10;        private set&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;        instance = this&#10;        database = Room.databaseBuilder(&#10;            this,&#10;            AppDatabase::class.java,&#10;            &quot;site_sync_db&quot;&#10;        ).build()&#10;        startKoin {&#10;            androidLogger()&#10;            androidContext(this@MainApp)&#10;            modules(appModule)&#10;        }&#10;        val config = mapOf(&#10;            &quot;cloud_name&quot; to &quot;YOUR_CLOUD_NAME&quot;,&#10;            &quot;api_key&quot; to &quot;YOUR_API_KEY&quot;,&#10;            &quot;api_secret&quot; to &quot;YOUR_API_SECRET&quot;&#10;        )&#10;        MediaManager.init(this, config)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/OverlayScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/OverlayScreen.kt" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;@Composable&#10;fun OverlayScreen(onNext: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        Button(onClick = onNext, modifier = Modifier) {&#10;            Text(&quot;Go to PreviewScreen&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/PreviewScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/PreviewScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;@Composable&#10;fun PreviewScreen(onNext: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        Button(onClick = onNext, modifier = Modifier.padding(padding)) {&#10;            Text(&quot;Go to SyncScreen&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/SyncScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/SyncScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync&#10;&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;&#10;@Composable&#10;fun SyncScreen(onBack: () -&gt; Unit, modifier: Modifier = Modifier) {&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        Button(onClick = onBack, modifier = Modifier.padding(padding)) {&#10;            Text(&quot;Back&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/database/Converters.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/database/Converters.kt" />
              <option name="originalContent" value="package com.a1.sitesync.data.database&#10;&#10;import androidx.room.TypeConverter&#10;import java.util.Date&#10;&#10;/**&#10; * Type converters to allow Room to reference complex data types.&#10; */&#10;class Converters {&#10;    @TypeConverter&#10;    fun fromTimestamp(value: Long?): Date? {&#10;        return value?.let { Date(it) }&#10;    }&#10;&#10;    @TypeConverter&#10;    fun dateToTimestamp(date: Date?): Long? {&#10;        return date?.time&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync.data.database&#10;&#10;import androidx.room.TypeConverter&#10;import com.google.gson.Gson&#10;import com.a1.sitesync.data.database.model.Dimensions&#10;import com.a1.sitesync.data.database.model.Provisions&#10;import java.util.Date&#10;&#10;/**&#10; * Type converters to allow Room to reference complex data types.&#10; */&#10;class Converters {&#10;    private val gson = Gson()&#10;&#10;    @TypeConverter&#10;    fun fromTimestamp(value: Long?): Date? {&#10;        return value?.let { Date(it) }&#10;    }&#10;&#10;    @TypeConverter&#10;    fun dateToTimestamp(date: Date?): Long? {&#10;        return date?.time&#10;    }&#10;&#10;    @TypeConverter&#10;    fun dimensionsToJson(dimensions: Dimensions?): String? {&#10;        return dimensions?.let { gson.toJson(it) }&#10;    }&#10;&#10;    @TypeConverter&#10;    fun jsonToDimensions(json: String?): Dimensions? {&#10;        return json?.let { gson.fromJson(it, Dimensions::class.java) }&#10;    }&#10;&#10;    @TypeConverter&#10;    fun provisionsToJson(provisions: Provisions?): String? {&#10;        return provisions?.let { gson.toJson(it) }&#10;    }&#10;&#10;    @TypeConverter&#10;    fun jsonToProvisions(json: String?): Provisions? {&#10;        return json?.let { gson.fromJson(it, Provisions::class.java) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/database/model/Provisions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/database/model/Provisions.kt" />
              <option name="originalContent" value="package com.a1.sitesync.data.database.model&#10;&#10;import androidx.room.ColumnInfo&#10;&#10;data class Provisions(&#10;    @ColumnInfo(name = &quot;has_cabling&quot;)&#10;    val hasCabling: Boolean,&#10;&#10;    @ColumnInfo(name = &quot;has_storage&quot;)&#10;    val hasStorage: Boolean&#10;)" />
              <option name="updatedContent" value="package com.a1.sitesync.data.database.model&#10;&#10;import androidx.room.ColumnInfo&#10;&#10;data class Provisions(&#10;    @ColumnInfo(name = &quot;has_cabling&quot;)&#10;    val hasCabling: Boolean = false,&#10;&#10;    @ColumnInfo(name = &quot;has_storage&quot;)&#10;    val hasStorage: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/repository/SiteSyncRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/data/repository/SiteSyncRepository.kt" />
              <option name="originalContent" value="package com.a1.sitesync.data.repository&#10;&#10;import com.a1.sitesync.data.database.dao.SurveyDao&#10;import com.a1.sitesync.data.database.model.Dimensions&#10;import com.a1.sitesync.data.database.model.Photo&#10;import com.a1.sitesync.data.database.model.Provisions&#10;import com.a1.sitesync.data.database.model.Survey&#10;import com.a1.sitesync.data.database.model.SurveyWithPhotos&#10;import com.a1.sitesync.data.models.FirestoreSurvey&#10;import com.a1.sitesync.data.models.SurveyDimensions&#10;import com.a1.sitesync.data.models.SurveyPhoto&#10;import com.a1.sitesync.data.models.SurveyProvisions&#10;import com.a1.sitesync.data.service.FirebaseSyncService&#10;import kotlinx.coroutines.flow.Flow&#10;import java.io.File&#10;import java.util.Date&#10;import java.util.UUID&#10;&#10;/**&#10; * The Repository now orchestrates data flow between the local Room DB&#10; * and the remote Firebase services.&#10; *&#10; * @param surveyDao The Data Access Object for surveys.&#10; * @param firebaseService The service for Firebase communications.&#10; */&#10;class SiteSyncRepository(&#10;    private val surveyDao: SurveyDao,&#10;    private val firebaseService: FirebaseSyncService,&#10;&#10;) {&#10;    private val firebaseSyncRepository: FirebaseSyncRepository&#10;&#10;&#10;    suspend fun createNewSurvey(&#10;        // ... (same parameters as before)&#10;        surveyorId: String,&#10;        clientName: String,&#10;        siteAddress: String?,&#10;        gateType: String,&#10;        dimensions: Dimensions,&#10;        provisions: Provisions,&#10;        openingDirection: String?,&#10;        recommendedGate: String?,&#10;        photoPaths: List&lt;String&gt;&#10;    ) {&#10;        // ... (same implementation as before to save locally)&#10;        val newSurveyId = UUID.randomUUID().toString()&#10;&#10;        val survey = Survey(&#10;            surveyId = newSurveyId,&#10;            surveyorId = surveyorId,&#10;            clientName = clientName,&#10;            siteAddress = siteAddress,&#10;            latitude = null,&#10;            longitude = null,&#10;            gateType = gateType,&#10;            dimensions = dimensions,&#10;            provisions = provisions,&#10;            openingDirection = openingDirection,&#10;            recommendedGate = recommendedGate,&#10;            status = &quot;Completed&quot;,&#10;            isSynced = false,&#10;            createdAt = Date()&#10;        )&#10;&#10;        val photos = photoPaths.map { path -&gt;&#10;            Photo(&#10;                photoId = UUID.randomUUID().toString(),&#10;                surveyIdRef = newSurveyId,&#10;                localFilePath = path,&#10;                cloudStorageUrl = null,&#10;                isSuperimposed = false,&#10;                capturedAt = Date()&#10;            )&#10;        }&#10;&#10;        surveyDao.insertSurveyWithPhotos(survey, photos)&#10;    }&#10;&#10;    /**&#10;     * Performs a full bi-directional data sync.&#10;     */&#10;    suspend fun performDataSync() {&#10;        // 1. Upstream Sync (Local -&gt; Cloud)&#10;        uploadUnsyncedSurveys()&#10;&#10;        // 2. Downstream Sync (Cloud -&gt; Local)&#10;        downloadRemoteSurveys()&#10;    }&#10;&#10;    /**&#10;     * Handles the upload of locally created/updated surveys to Firebase.&#10;     */&#10;    private suspend fun uploadUnsyncedSurveys() {&#10;        val unsyncedSurveys = surveyDao.getUnsyncedSurveys()&#10;&#10;        unsyncedSurveys.forEach { surveyWithPhotos -&gt;&#10;            val survey = surveyWithPhotos.survey&#10;            val photos = surveyWithPhotos.photos&#10;&#10;            // 1. Upload all photos for the survey to Cloud Storage&#10;            val uploadedPhotos = photos.map { photo -&gt;&#10;                val localFile = File(photo.localFilePath)&#10;                val cloudUrl = firebaseService.uploadFile(localFile, survey.surveyId)&#10;                SurveyPhoto(&#10;                    photoId = photo.photoId,&#10;                    cloudStorageUrl = cloudUrl,&#10;                    isSuperimposed = photo.isSuperimposed&#10;                    // 'capturedAt' will be set by server timestamp&#10;                )&#10;            }&#10;&#10;            // 2. Prepare the Firestore document&#10;            val firestoreSurvey = FirestoreSurvey(&#10;                surveyId = survey.surveyId,&#10;                surveyorId = survey.surveyorId,&#10;                clientName = survey.clientName,&#10;                siteAddress = survey.siteAddress,&#10;                gateType = survey.gateType,&#10;                dimensions = SurveyDimensions(&#10;                    clearOpeningWidth = survey.dimensions.clearOpeningWidth,&#10;                    requiredHeight = survey.dimensions.requiredHeight,&#10;                    parkingSpaceLength = survey.dimensions.parkingSpaceLength,&#10;                    openingAngleLeaf = survey.dimensions.openingAngleLeaf&#10;                ),&#10;                provisions = SurveyProvisions(&#10;                    hasCabling = survey.provisions.hasCabling,&#10;                    hasStorage = survey.provisions.hasStorage&#10;                ),&#10;                openingDirection = survey.openingDirection,&#10;                recommendedGate = survey.recommendedGate,&#10;                photos = uploadedPhotos&#10;            )&#10;&#10;            // 3. Upload the document to Firestore&#10;            firebaseService.uploadSurveyDocument(firestoreSurvey)&#10;&#10;            // 4. Mark the local survey as synced&#10;            surveyDao.markSurveyAsSynced(survey.surveyId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetches surveys from Firestore and updates local DB&#10;     */&#10;    private suspend fun downloadRemoteSurveys() {&#10;        val remoteSurveys = firebaseService.fetchAllSurveys()&#10;        remoteSurveys.forEach { fs -&gt;&#10;            val survey = Survey(&#10;                surveyId = fs.surveyId,&#10;                surveyorId = fs.surveyorId,&#10;                clientName = fs.clientName,&#10;                siteAddress = fs.siteAddress,&#10;                latitude = fs.location?.latitude,&#10;                longitude = fs.location?.longitude,&#10;                gateType = fs.gateType,&#10;                dimensions = Dimensions(&#10;                    clearOpeningWidth = fs.dimensions.clearOpeningWidth,&#10;                    requiredHeight = fs.dimensions.requiredHeight,&#10;                    parkingSpaceLength = fs.dimensions.parkingSpaceLength,&#10;                    openingAngleLeaf = fs.dimensions.openingAngleLeaf&#10;                ),&#10;                provisions = Provisions(&#10;                    hasCabling = fs.provisions.hasCabling,&#10;                    hasStorage = fs.provisions.hasStorage&#10;                ),&#10;                openingDirection = fs.openingDirection,&#10;                recommendedGate = fs.recommendedGate,&#10;                status = fs.status,&#10;                isSynced = true,&#10;                createdAt = fs.createdAt ?: Date()&#10;            )&#10;            val photos = fs.photos.map { sp -&gt;&#10;                Photo(&#10;                    photoId = sp.photoId,&#10;                    surveyIdRef = fs.surveyId,&#10;                    localFilePath = &quot;&quot;, // Remote photos, no local file&#10;                    cloudStorageUrl = sp.cloudStorageUrl,&#10;                    isSuperimposed = sp.isSuperimposed,&#10;                    capturedAt = sp.capturedAt ?: Date()&#10;                )&#10;            }&#10;            surveyDao.insertSurveyWithPhotos(survey, photos)&#10;        }&#10;    }&#10;&#10;    /** CRUD operations (OFFLINE - Room) **/&#10;    fun getAllSurveys(): Flow&lt;List&lt;SurveyWithPhotos&gt;&gt; = surveyDao.getAllSurveys()&#10;&#10;    fun getSurveyById(surveyId: String): Flow&lt;SurveyWithPhotos&gt; = surveyDao.getSurveyById(surveyId)&#10;&#10;    suspend fun updateSurvey(survey: Survey) = surveyDao.updateSurvey(survey)&#10;&#10;    suspend fun deleteSurvey(survey: Survey) = surveyDao.deleteSurvey(survey)&#10;&#10;    /** CRUD operations (ONLINE - Firestore) **/&#10;    suspend fun upsertSurveyOnline(firestoreSurvey: FirestoreSurvey) =&#10;        firebaseSyncRepository.upsertSurvey(firestoreSurvey)&#10;&#10;    suspend fun getAllSurveysOnline(): List&lt;FirestoreSurvey&gt; =&#10;        firebaseSyncRepository.getAllSurveys()&#10;&#10;    suspend fun getSurveyByIdOnline(surveyId: String): FirestoreSurvey? =&#10;        firebaseSyncRepository.getSurveyById(surveyId)&#10;&#10;    suspend fun deleteSurveyOnline(surveyId: String) =&#10;        firebaseSyncRepository.deleteSurvey(surveyId)&#10;&#10;    /**&#10;     * Adds a photo entry to an existing survey.&#10;     */&#10;    suspend fun addPhotoToSurvey(surveyId: String, localFilePath: String) {&#10;        val photo = Photo(&#10;            photoId = UUID.randomUUID().toString(),&#10;            surveyIdRef = surveyId,&#10;            localFilePath = localFilePath,&#10;            cloudStorageUrl = null,&#10;            isSuperimposed = false,&#10;            capturedAt = Date()&#10;        )&#10;        surveyDao.insertPhotos(listOf(photo))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.a1.sitesync.data.repository&#10;&#10;import com.a1.sitesync.data.database.dao.SurveyDao&#10;import com.a1.sitesync.data.database.model.Dimensions&#10;import com.a1.sitesync.data.database.model.Photo&#10;import com.a1.sitesync.data.database.model.Provisions&#10;import com.a1.sitesync.data.database.model.Survey&#10;import com.a1.sitesync.data.database.model.SurveyWithPhotos&#10;import com.a1.sitesync.data.models.FirestoreSurvey&#10;import com.a1.sitesync.data.models.SurveyDimensions&#10;import com.a1.sitesync.data.models.SurveyPhoto&#10;import com.a1.sitesync.data.models.SurveyProvisions&#10;import com.a1.sitesync.data.service.FirebaseSyncService&#10;import kotlinx.coroutines.flow.Flow&#10;import java.io.File&#10;import java.util.Date&#10;import java.util.UUID&#10;&#10;/**&#10; * The Repository now orchestrates data flow between the local Room DB&#10; * and the remote Firebase services.&#10; *&#10; * @param surveyDao The Data Access Object for surveys.&#10; * @param firebaseService The service for Firebase communications.&#10; */&#10;class SiteSyncRepository(&#10;    private val surveyDao: SurveyDao,&#10;    private val firebaseService: FirebaseSyncService,&#10;    private val firebaseSyncRepository: FirebaseSyncRepository&#10;) {&#10;    suspend fun createNewSurvey(&#10;        // ... (same parameters as before)&#10;        surveyorId: String,&#10;        clientName: String,&#10;        siteAddress: String?,&#10;        gateType: String,&#10;        dimensions: Dimensions,&#10;        provisions: Provisions,&#10;        openingDirection: String?,&#10;        recommendedGate: String?,&#10;        photoPaths: List&lt;String&gt;&#10;    ) {&#10;        // ... (same implementation as before to save locally)&#10;        val newSurveyId = UUID.randomUUID().toString()&#10;&#10;        val survey = Survey(&#10;            surveyId = newSurveyId,&#10;            surveyorId = surveyorId,&#10;            clientName = clientName,&#10;            siteAddress = siteAddress,&#10;            latitude = null,&#10;            longitude = null,&#10;            gateType = gateType,&#10;            dimensions = dimensions,&#10;            provisions = provisions,&#10;            openingDirection = openingDirection,&#10;            recommendedGate = recommendedGate,&#10;            status = &quot;Completed&quot;,&#10;            isSynced = false,&#10;            createdAt = Date()&#10;        )&#10;&#10;        val photos = photoPaths.map { path -&gt;&#10;            Photo(&#10;                photoId = UUID.randomUUID().toString(),&#10;                surveyIdRef = newSurveyId,&#10;                localFilePath = path,&#10;                cloudStorageUrl = null,&#10;                isSuperimposed = false,&#10;                capturedAt = Date()&#10;            )&#10;        }&#10;&#10;        surveyDao.insertSurveyWithPhotos(survey, photos)&#10;    }&#10;&#10;    /**&#10;     * Performs a full bi-directional data sync.&#10;     */&#10;    suspend fun performDataSync() {&#10;        // 1. Upstream Sync (Local -&gt; Cloud)&#10;        uploadUnsyncedSurveys()&#10;&#10;        // 2. Downstream Sync (Cloud -&gt; Local)&#10;        downloadRemoteSurveys()&#10;    }&#10;&#10;    /**&#10;     * Handles the upload of locally created/updated surveys to Firebase.&#10;     */&#10;    private suspend fun uploadUnsyncedSurveys() {&#10;        val unsyncedSurveys = surveyDao.getUnsyncedSurveys()&#10;&#10;        unsyncedSurveys.forEach { surveyWithPhotos -&gt;&#10;            val survey = surveyWithPhotos.survey&#10;            val photos = surveyWithPhotos.photos&#10;&#10;            // 1. Upload all photos for the survey to Cloud Storage&#10;            val uploadedPhotos = photos.map { photo -&gt;&#10;                val localFile = File(photo.localFilePath)&#10;                val cloudUrl = firebaseService.uploadFile(localFile, survey.surveyId)&#10;                SurveyPhoto(&#10;                    photoId = photo.photoId,&#10;                    cloudStorageUrl = cloudUrl,&#10;                    isSuperimposed = photo.isSuperimposed&#10;                    // 'capturedAt' will be set by server timestamp&#10;                )&#10;            }&#10;&#10;            // 2. Prepare the Firestore document&#10;            val firestoreSurvey = FirestoreSurvey(&#10;                surveyId = survey.surveyId,&#10;                surveyorId = survey.surveyorId,&#10;                clientName = survey.clientName,&#10;                siteAddress = survey.siteAddress,&#10;                gateType = survey.gateType,&#10;                dimensions = SurveyDimensions(&#10;                    clearOpeningWidth = survey.dimensions.clearOpeningWidth,&#10;                    requiredHeight = survey.dimensions.requiredHeight,&#10;                    parkingSpaceLength = survey.dimensions.parkingSpaceLength,&#10;                    openingAngleLeaf = survey.dimensions.openingAngleLeaf&#10;                ),&#10;                provisions = SurveyProvisions(&#10;                    hasCabling = survey.provisions.hasCabling,&#10;                    hasStorage = survey.provisions.hasStorage&#10;                ),&#10;                openingDirection = survey.openingDirection,&#10;                recommendedGate = survey.recommendedGate,&#10;                photos = uploadedPhotos&#10;            )&#10;&#10;            // 3. Upload the document to Firestore&#10;            firebaseService.uploadSurveyDocument(firestoreSurvey)&#10;&#10;            // 4. Mark the local survey as synced&#10;            surveyDao.markSurveyAsSynced(survey.surveyId)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fetches surveys from Firestore and updates local DB&#10;     */&#10;    private suspend fun downloadRemoteSurveys() {&#10;        val remoteSurveys = firebaseService.fetchAllSurveys()&#10;        remoteSurveys.forEach { fs -&gt;&#10;            val survey = Survey(&#10;                surveyId = fs.surveyId,&#10;                surveyorId = fs.surveyorId,&#10;                clientName = fs.clientName,&#10;                siteAddress = fs.siteAddress,&#10;                latitude = fs.location?.latitude,&#10;                longitude = fs.location?.longitude,&#10;                gateType = fs.gateType,&#10;                dimensions = Dimensions(&#10;                    clearOpeningWidth = fs.dimensions.clearOpeningWidth,&#10;                    requiredHeight = fs.dimensions.requiredHeight,&#10;                    parkingSpaceLength = fs.dimensions.parkingSpaceLength,&#10;                    openingAngleLeaf = fs.dimensions.openingAngleLeaf&#10;                ),&#10;                provisions = Provisions(&#10;                    hasCabling = fs.provisions.hasCabling,&#10;                    hasStorage = fs.provisions.hasStorage&#10;                ),&#10;                openingDirection = fs.openingDirection,&#10;                recommendedGate = fs.recommendedGate,&#10;                status = fs.status,&#10;                isSynced = true,&#10;                createdAt = fs.createdAt ?: Date()&#10;            )&#10;            val photos = fs.photos.map { sp -&gt;&#10;                Photo(&#10;                    photoId = sp.photoId,&#10;                    surveyIdRef = fs.surveyId,&#10;                    localFilePath = &quot;&quot;, // Remote photos, no local file&#10;                    cloudStorageUrl = sp.cloudStorageUrl,&#10;                    isSuperimposed = sp.isSuperimposed,&#10;                    capturedAt = sp.capturedAt ?: Date()&#10;                )&#10;            }&#10;            surveyDao.insertSurveyWithPhotos(survey, photos)&#10;        }&#10;    }&#10;&#10;    /** CRUD operations (OFFLINE - Room) **/&#10;    fun getAllSurveys(): Flow&lt;List&lt;SurveyWithPhotos&gt;&gt; = surveyDao.getAllSurveys()&#10;&#10;    fun getSurveyById(surveyId: String): Flow&lt;SurveyWithPhotos&gt; = surveyDao.getSurveyById(surveyId)&#10;&#10;    suspend fun updateSurvey(survey: Survey) = surveyDao.updateSurvey(survey)&#10;&#10;    suspend fun deleteSurvey(survey: Survey) = surveyDao.deleteSurvey(survey)&#10;&#10;    /** CRUD operations (ONLINE - Firestore) **/&#10;    suspend fun upsertSurveyOnline(firestoreSurvey: FirestoreSurvey) =&#10;        firebaseSyncRepository.upsertSurvey(firestoreSurvey)&#10;&#10;    suspend fun getAllSurveysOnline(): List&lt;FirestoreSurvey&gt; =&#10;        firebaseSyncRepository.getAllSurveys()&#10;&#10;    suspend fun getSurveyByIdOnline(surveyId: String): FirestoreSurvey? =&#10;        firebaseSyncRepository.getSurveyById(surveyId)&#10;&#10;    suspend fun deleteSurveyOnline(surveyId: String) =&#10;        firebaseSyncRepository.deleteSurvey(surveyId)&#10;&#10;    /**&#10;     * Adds a photo entry to an existing survey.&#10;     */&#10;    suspend fun addPhotoToSurvey(surveyId: String, localFilePath: String) {&#10;        val photo = Photo(&#10;            photoId = UUID.randomUUID().toString(),&#10;            surveyIdRef = surveyId,&#10;            localFilePath = localFilePath,&#10;            cloudStorageUrl = null,&#10;            isSuperimposed = false,&#10;            capturedAt = Date()&#10;        )&#10;        surveyDao.insertPhotos(listOf(photo))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/workers/SyncWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/a1/sitesync/workers/SyncWorker.kt" />
              <option name="originalContent" value="package com.a1.sitesync.workers&#10;&#10;import android.content.Context&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.WorkerParameters&#10;import com.a1.sitesync.MainApp&#10;import com.a1.sitesync.data.repository.SiteSyncRepository&#10;import com.a1.sitesync.data.service.FirebaseSyncService&#10;&#10;/**&#10; * A CoroutineWorker responsible for performing the bi-directional data synchronization.&#10; * WorkManager will execute this task in the background, respecting battery optimizations&#10; * and retrying on failure.&#10; *&#10; * @param appContext The application context.&#10; * @param workerParams Parameters for the worker.&#10; */&#10;class SyncWorker(&#10;    appContext: Context,&#10;    workerParams: WorkerParameters&#10;) : CoroutineWorker(appContext, workerParams) {&#10;&#10;    // Note: In a real app, you would use Dependency Injection (e.g., Hilt)&#10;    // to get instances of your repository and services.&#10;    private val repository: SiteSyncRepository by lazy {&#10;        // This is a simplified instantiation.&#10;        // You should have a proper DI setup to provide the DAO.&#10;        val surveyDao = (appContext as MainApp).database.surveyDao()&#10;        SiteSyncRepository(surveyDao, FirebaseSyncService(&#10;            cloudinaryService = com.a1.sitesync.data.service.CloudinarySyncService()&#10;        ), com.a1.sitesync.data.repository.FirebaseSyncRepository())&#10;    }&#10;&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Perform the full synchronization logic&#10;            repository.performDataSync()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            // If any part of the sync fails, retry the work later&#10;            Result.retry()&#10;        }&#10;    }&#10;}&#10;&#10;// Placeholder for your Application class where you'd initialize the database&#10;// and potentially WorkManager scheduling.&#10;// abstract class YourApplicationClass : android.app.Application() {&#10;//     abstract val database: YourAppDatabase&#10;// }&#10;" />
              <option name="updatedContent" value="package com.a1.sitesync.workers&#10;&#10;import android.content.Context&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.WorkerParameters&#10;import com.a1.sitesync.data.repository.SiteSyncRepository&#10;import org.koin.core.component.KoinComponent&#10;import org.koin.core.component.inject&#10;&#10;/**&#10; * A CoroutineWorker responsible for performing the bi-directional data synchronization.&#10; * WorkManager will execute this task in the background, respecting battery optimizations&#10; * and retrying on failure.&#10; *&#10; * @param appContext The application context.&#10; * @param workerParams Parameters for the worker.&#10; */&#10;class SyncWorker(&#10;    appContext: Context,&#10;    workerParams: WorkerParameters&#10;) : CoroutineWorker(appContext, workerParams), KoinComponent {&#10;&#10;    // Inject repository via Koin&#10;    private val repository: SiteSyncRepository by inject()&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Perform the full synchronization logic&#10;            repository.performDataSync()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            // If any part of the sync fails, retry the work later&#10;            Result.retry()&#10;        }&#10;    }&#10;}&#10;&#10;// Placeholder for your Application class where you'd initialize the database&#10;// and potentially WorkManager scheduling.&#10;// abstract class YourApplicationClass : android.app.Application() {&#10;//     abstract val database: YourAppDatabase&#10;// }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>